# -*- coding: utf-8 -*-
"""Matchproject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VvbGr402yJhAvElDh1pS0SjhmlbOvy1a
"""

import pandas as pd

from google.colab import files
uploaded = files.upload()

matches = pd.read_csv("matches.csv", index_col=0)

matches.head()

matches.shape

#38matches in a season and 20 teams each season and we have data for 2 seasons
38 * 20 * 2
#whatever the value we get it is the total data we should have

#we have 1389 and the data is supposed to be 1520

matches["team"].value_counts()
#it will tell us how many matches we have for each team in our data

#some teams our degraded each year and some are upgraded so we expect 6 teams to have fewer than 70 matches but we have 7 teams in our data set <than 70 matches
matches[matches["team"] == "Liverpool"]

matches["round"].value_counts() #round column tells you whic matchweek each match was played

matches.dtypes #tells about the data present in each column

#ML algos cannot work with any other data except float64 and int64 so here we have to change the object to numeric value
matches["date"] = pd.to_datetime(matches["date"])
#converting the existing column to date time and over writing it with datetime

matches.dtypes

#creating predictors for machine learning
#venue predicts if the team played an away game or a home game, important predictor for the outcome of matches , So now we will convert them into numbers
matches["venue_code"] = matches["venue"].astype("category").cat.codes#converting string to category and then category to numbers

matches

matches["opp_code"] = matches["opponent"].astype("category").cat.codes

matches

#now looking into hour column as some teams play better at some time of the day, so basically in the time column we want to remove the min and just keep the hour
matches["hour"] = matches["time"].str.replace(":.+","", regex=True).astype("int")

matches

matches["day_code"] = matches["date"].dt.dayofweek

matches

#train
#target weather team won or not
matches["target"] = (matches["result"] == "W").astype("int")
#result can be L,W,D loss,win,draw so we will divide it into 1 or 0,asstype int will convert true or false obtained to 1 or 0

#creating our initial ML model
from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier(n_estimators=50, min_samples_split=10, random_state=1)

train = matches[matches["date"] < '2022-01-01']

test = matches[matches["date"] > '2022-01-01']

predictors = ["venue_code", "opp_code", "hour", "day_code"]

rf.fit(train[predictors], train["target"])

preds = rf.predict(test[predictors])

from sklearn.metrics import accuracy_score

acc = accuracy_score(test["target"], preds)

acc

combined = pd.DataFrame(dict(actual=test["target"], prediction=preds))
#wetryto find out in which situations our accuracy was high vs low, for that we need to create a dataframe by combining by actual and predicted values

#creating a two way table to give us better idea
pd.crosstab(index=combined["actual"], columns=combined["prediction"])

#we carebout having win so we need to revise our accuracy matrix a bit
#use different matrix
from sklearn.metrics import precision_score
#this will tell us when we predicted a win, what percentage of time did we actually win

precision_score(test["target"], preds)

#IMPROVING PRECISION WITH ROLLING AVERAGES
grouped_matches = matches.groupby("team")#this will create one db for every swuad in our data

group = grouped_matches.get_group("Manchester City")

group

def rolling_averages(group, cols, new_cols):
    group = group.sort_values("date")
    rolling_stats = group[cols].rolling(3, closed='left').mean() #important cause if not put then they will compute rolling avg for prev 3 week and assign it to 3rd week but we want it for the 4th week

    group[new_cols] = rolling_stats
    group = group.dropna(subset=new_cols) #drop any missing values
    return group

cols = ["gf", "ga", "sh", "sot", "dist", "fk", "pk", "pkatt"] #colums for which we want to compute rolling avg
new_cols = [f"{c}_rolling" for c in cols] #format string adding rolling on to the end

new_cols

rolling_averages(group, cols, new_cols)

matches_rolling = matches.groupby("team").apply(lambda x: rolling_averages(x, cols, new_cols))
#this will apply one function to each team here rolling function

matches_rolling

#drop the extra index level
matches_rolling = matches_rolling.droplevel('team')

matches_rolling

matches_rolling.index = range(matches_rolling.shape[0]) #will assign from 0 to 1316 to be our indices

#RETRAINF OUR ML model. , we have some new predictors we can make new set of predictions using these predictions
def make_predictions(data, predictors):
    train = data[data["date"] < '2022-01-01']
    test = data[data["date"] > '2022-01-01']
    rf.fit(train[predictors], train["target"])
    preds = rf.predict(test[predictors])
    combined = pd.DataFrame(dict(actual=test["target"], predicted=preds), index=test.index)
    precision = precision_score(test["target"], preds)
    return combined, precision

combined, precision = make_predictions(matches_rolling, predictors + new_cols)

precision

combined #done to check where our mispredictions were , it doesn't exactly tell us which team actually played in each match, so we can't say if we are mispredicting any team, we can fix this by adding some of the info to the combined

combined = combined.merge(matches_rolling[["date", "team", "opponent", "result"]], left_index=True, right_index=True)
#here, pandas will look in our combined dataframe eg. index here is 55, it will find same index from matches_rolling and it will merge the row

combined

#COMBINING HOME AND AWAY PREDICTIONS
#We will look at how our algo did at predicting both side of the match
class MissingDict(dict):
    __missing__ = lambda self, key: key

map_values = {"Brighton and Hove Albion": "Brighton",
              "Manchester United": "Manchester Utd",
              "Newcastle United": "Newcastle Utd",
              "Tottenham Hotspur": "Tottenham",
              "West Ham United": "West Ham",
              "Wolverhampton Wanderers": "Wolves"}
mapping = MissingDict(**map_values)

mapping["West Ham United"]

combined["new_team"] = combined["team"].map(mapping)

combined

merged = combined.merge(combined, left_on=["date", "new_team"], right_on=["date", "opponent"])

merged

merged[(merged["predicted_x"] == 1) & (merged["predicted_y"] ==0)]["actual_x"].value_counts()

